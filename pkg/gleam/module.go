package gleam

import (
	"strings"
	"text/template"

	"github.com/bwireman/gleam_pb/pkg/gleam/fields"
	pgs "github.com/lyft/protoc-gen-star"
)

type GleamModule struct {
	*pgs.ModuleBase
	tpl *template.Template
}

func Gleam() *GleamModule { return &GleamModule{ModuleBase: &pgs.ModuleBase{}} }

func (g *GleamModule) InitContext(c pgs.BuildContext) {
	g.ModuleBase.InitContext(c)

	g.tpl = template.Must(template.New("gleam-package-template").Parse(gleamTemplate))
}

func (g *GleamModule) Name() string { return "gleam" }

func (g *GleamModule) Execute(_targets map[string]pgs.File, pkgs map[string]pgs.Package) []pgs.Artifact {
	g.AddCustomFile(g.OutputPath()+"/gleam_pb.gleam", gleam_pb, 0644)

	for _, p := range pkgs {
		allMessages := []pgs.Message{}
		allEnums := []pgs.Enum{}
		imports := []string{"gleam/option", "gleam/list", "gleam/map", "gleam_pb"}

		for _, file := range p.Files() {
			allMessages = append(allMessages, file.AllMessages()...)
			allEnums = append(allEnums, file.AllEnums()...)

			for _, imp := range file.Imports() {
				if imp.Package().ProtoName() != p.ProtoName() {
					imports = append(imports, strings.Replace(imp.Name().String(), ".proto", "", -1))
				}
			}
		}

		g.generate(allMessages, allEnums, p, imports)
	}

	return g.Artifacts()
}

func (g *GleamModule) generate(all_messages []pgs.Message, all_enums []pgs.Enum, pkg pgs.Package, imports []string) {

	gleam_types_map := []map[string]interface{}{}
	generators := []map[string]interface{}{}

	for _, enum := range all_enums {
		// don't need enum generators
		gleam_types_map = append(gleam_types_map, fields.GleamTypeFromEnum(enum).RenderAsMap())
	}

	for _, msg := range all_messages {
		for _, oo := range msg.OneOfs() {
			// don't need oneof generators
			gleam_types_map = append(gleam_types_map, fields.GleamTypeFromOnoeOf(msg, oo).RenderAsMap())
		}

		msg_gleam_type := fields.GleamTypeFromMessage(msg)

		if generator := fields.GeneratorFnFromGleamType(msg_gleam_type); generator != nil {
			generators = append(generators, generator.RenderAsMap())
		}

		gleam_types_map = append(gleam_types_map, msg_gleam_type.RenderAsMap())
	}

	g.AddGeneratorTemplateFile(strings.Replace(pkg.ProtoName().String(), ".", "/", -1)+".gleam", g.tpl, map[string]interface{}{
		"imports":    imports,
		"package":    pkg.ProtoName().LowerSnakeCase().String(),
		"messages":   gleam_types_map,
		"generators": generators,
	})
}

const gleamTemplate = `
{{ range .imports }}
import {{ . }}
{{ end }}

/// {{ .package }} package types generated by gleam_pb
/// DO NOT EDIT

{{ range .messages }}
pub type {{ .type_name }} {
  {{ range .constructors -}}
    {{ . }}
  {{ end }}
}
{{ end }}

{{ range .generators }}
pub fn {{ .func_name }}() {
	{{ .type_name }}({{ .fields }})
}
{{ end }}
`

const gleam_pb = `import gleam/map
import gleam/list

/// Built-in types used in generated gleam_pb types
/// These types correspond to their WKT equivalents
pub external type Any

pub type Value =
  Any

pub type Timestamp {
  Timestamp(seconds: Int, nanos: Int)
}

pub type Duration =
  Timestamp

pub type Empty =
  #()

pub type Struct =
  map.Map(String, Value)
`
